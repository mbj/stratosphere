{-# LANGUAGE QuasiQuotes #-}

module Stratosphere.Manager.Generator.Main (main) where

import Control.Monad (when)
import Data.Set (Set)
import Data.String (fromString)
import Stratosphere.Manager.Generator.Declaration
import Stratosphere.Manager.Generator.Module
import Stratosphere.Manager.Generator.Prelude
import Stratosphere.Manager.ModelPath (modelFilePath)
import System.Directory
import System.FilePath.Posix
import Text.Shakespeare.Text (st)

import qualified Data.Map                           as Map
import qualified Data.Maybe                         as Maybe
import qualified Data.Set                           as Set
import qualified Data.Text                          as Text
import qualified Data.Text.IO                       as Text
import qualified Data.Version                       as Version
import qualified GHC.SourceGen                      as GHC
import qualified Hpack
import qualified Paths_stratosphere                 as Stratosphere
import qualified Stratosphere.Manager.Generator.Raw as Raw

main :: IO ()
main = do
  rawSpec <- either error id <$> Raw.readSpec modelFilePath

  removeDirectoryIfExists "services"
  removeDirectoryIfExists "gen"

  generate rawSpec
  where
    removeDirectoryIfExists name = do
      exists <- doesDirectoryExist name
      when exists $ removeDirectoryRecursive name

generate :: Raw.Spec -> IO ()
generate Raw.Spec{..} = do
  traverse_ (uncurry writeResourceTypeModule) $ Map.toList specResourceTypes
  traverse_ (uncurry writePropertyTypeModule) $ Map.toList specPropertyTypes
  traverse_ writePackage services
  where
    services = Set.toList . Set.fromList $ (.service) <$> Map.keys specResourceTypes

writePackage :: Raw.Service -> IO ()
writePackage service = do
  System.Directory.copyFile globalLicenseFile serviceLicenseFile
  Text.putStrLn $ "Writing: " <> Text.pack servicePackageFile
  Text.writeFile servicePackageFile [st|# Generated by stratosphere-gen
_common/package: !include "../../common/package.yaml"

name: #{servicePackageName}
version: #{serviceVersion}
synopsis: Stratosphere integration for AWS #{service.service}.
description: Integration into stratosphere to generate resources and properties for AWS #{service.service}
category: AWS, Cloud, #{service.service}
license-file: LICENSE.md
library:
  source-dirs: gen
  ghc-options:
  - -Wno-unused-imports
<<: *defaults

dependencies:
- aeson >= 2 && < 3
- base  >= 4.8  && < 4.22
- stratosphere == #{serviceVersion}
|]
  withCurrentDirectory directory $ Hpack.hpack Hpack.NoVerbose Hpack.defaultOptions
  where
    directory          = serviceDirectory service
    serviceLicenseFile = directory </> globalLicenseFile
    servicePackageFile = directory </> "package.yaml"
    servicePackageName = "stratosphere-" <> packageSlug service
    serviceVersion     = Version.showVersion Stratosphere.version

    globalLicenseFile :: FilePath
    globalLicenseFile  = "LICENSE.md"

moduleFileName :: GHC.ModuleNameStr -> FilePath
moduleFileName moduleName = go "gen" (Text.unpack <$> components)
  where
    go :: FilePath -> [String] -> FilePath
    go _acc [] = error "Empty module Name?"
    go acc [file] = acc </> (file <.> ".hs")
    go acc (next:reminder) = go (acc </> next) reminder

    components = Text.split (== '.') $ Text.pack $ GHC.moduleNameStrToString moduleName

writeResourceTypeModule :: Raw.ResourceTypeName -> Raw.ResourceType -> IO ()
writeResourceTypeModule resourceTypeName Raw.ResourceType{..} = do
  writeModule moduleFilePath $
    GHC.module'
      (Just moduleName)
      (Just exports)
      (renderImports moduleName (pure resourceTypeName) imports)
      declarations
  where
    moduleFilePath = serviceDirectory service </> moduleFileName moduleName

    (declarations, State{..})
      = genRecord
        Record
        { awsType       = toText resourceTypeName
        , builderName   = "mk" <> recordName
        , name          = recordName
        , properties    = resourceTypeProperties
        , documentation = resourceTypeDocumentation
        }

    recordName = resourceTypeName.resource

    moduleName :: GHC.ModuleNameStr
    moduleName
      = fromString
      . Text.unpack
      $ Text.intercalate "."
      [ "Stratosphere"
      , service.service
      , resourceTypeName.resource
      ]

    service :: Raw.Service
    service = resourceTypeName.service

writePropertyTypeModule
  :: HasCallStack
  => Raw.PropertyTypeName
  -> Raw.PropertyType
  -> IO ()
writePropertyTypeModule propertyTypeName propertyType@Raw.PropertyType{..} = do
  case propertyTypeProperties of
    Nothing -> do
      writeModule moduleFilePath typeAliasModule
      writeModule (moduleFilePath <> "-boot") $ typeAliasModule
    (Just properties) -> do
      writeModule moduleFilePath $ recordModule properties
      writeModule (moduleFilePath <> "-boot") $ recordModuleBoot
  where
    (directory, typeName, resourceTypeName) = case propertyTypeName of
      Raw.Tag -> (".", "Tag", Nothing)
      (Raw.PropertyTypeName resourceTypeName' propertyName) ->
        ( (serviceDirectory $ resourceTypeName'.service)
        , Raw.mkPropertyTypeName propertyName
        , pure resourceTypeName'
        )

    moduleFilePath = directory </> moduleFileName moduleName
    moduleName     = propertyTypeModuleName propertyTypeName

    typeAliasModule :: HasCallStack => GHC.HsModule'
    typeAliasModule =
      GHC.module'
        (Just moduleName)
        (Just exports)
        (renderImports moduleName resourceTypeName imports)
        [typeAlias]
        where
          (typeAlias, State{..}) = genTypeAlias propertyTypeName propertyType

    recordModule properties =
      GHC.module'
        (Just moduleName)
        (Just exports)
        (renderImports moduleName resourceTypeName imports)
        declarations
        where
          (declarations, State{..})
            = genRecord
              Record
              { awsType       = toText propertyTypeName
              , builderName   = "mk" <> typeName
              , name          = typeName
              , properties    = properties
              , documentation = propertyTypeDocumentation
              }

    recordModuleBoot =
      GHC.module'
        (Just moduleName)
        Nothing
        (renderImports moduleName resourceTypeName imports)
        declarations
        where
          (declarations, State{..})
            = genRecordBoot
              Record
              { awsType       = toText propertyTypeName
              , builderName   = "mk" <> typeName
              , name          = typeName
              , properties    = []
              , documentation = ""
              }

renderImports :: GHC.ModuleNameStr -> Maybe Raw.ResourceTypeName -> Set Import -> [GHC.ImportDecl']
renderImports currentModuleName resourceTypeName = Maybe.mapMaybe mkImport . Set.toList
  where
    mkImport = \case
      JSON                     -> Just $ GHC.qualified' $ GHC.import' "Data.Aeson" `GHC.as'` "JSON"
      Prelude                  -> Just $ GHC.qualified' $ GHC.import' "Stratosphere.Prelude" `GHC.as'` "Prelude"
      Property                 -> Just $ GHC.import' "Stratosphere.Property"
      ResourceProperties       -> Just $ GHC.import' "Stratosphere.ResourceProperties"
      Tag                      -> Just $ GHC.import' "Stratosphere.Tag"
      Value                    -> Just $ GHC.import' "Stratosphere.Value"
      (Reference propertyName) ->
        case resourceTypeName of
          (Just resourceTypeName') ->
             let refModuleName = resourceTypePropertyModuleName resourceTypeName' propertyName
             in if refModuleName == currentModuleName
                   then Nothing  -- Skip self-references
                   else Just $ GHC.source $ GHC.import' refModuleName `GHC.as'` "Exports"
          Nothing -> error $ "Unresolved reference to: " <> show propertyName

packageSlug :: Raw.Service -> Text
packageSlug service = Text.toLower (getField @"service" service)

serviceDirectory :: Raw.Service -> FilePath
serviceDirectory service = "services" </> Text.unpack (packageSlug service)

propertyTypeModuleName :: Raw.PropertyTypeName -> GHC.ModuleNameStr
propertyTypeModuleName = \case
  Raw.Tag -> tagModuleName
  (Raw.PropertyTypeName resourceTypeName propertyName) -> resourceTypePropertyModuleName resourceTypeName propertyName

tagModuleName :: GHC.ModuleNameStr
tagModuleName = "Stratosphere.Tag"

resourceTypePropertyModuleName :: Raw.ResourceTypeName -> Raw.PropertyName -> GHC.ModuleNameStr
resourceTypePropertyModuleName resourceTypeName propertyName
  = fromString
  . Text.unpack
  $ Text.intercalate "."
  [ "Stratosphere"
  , getField @"service" (getField @"service" resourceTypeName)
  , getField @"resource" resourceTypeName
  , Raw.toText propertyName <> "Property"
  ]
